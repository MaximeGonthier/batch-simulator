\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{diagbox}
\usepackage{colortbl}
\usepackage{pdfpages}
\usepackage{todonotes}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xspace}
\usepackage{xcolor,pifont}
\usepackage{fullpage}
\usepackage{algorithm, algpseudocode}
\usepackage[hidelinks]{hyperref}
\usepackage[english]{babel}
%~ \usepackage[backend=bibtex]{biblatex}
%~ \bibliography{ref_cadre}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newtheorem{Problem}{Problem}
\newtheorem{Theorem}{Theorem}
\newtheorem{Lemma}{Lemma}
\newtheorem{Hypothesis}{Hypothesis}
\providecommand{\keywords}[1]{\textbf{\textit{Key-words:}} #1}
\newcommand{\LM}[1]{\textcolor{red}{LM:~{#1}}}
\newcommand{\ST}[1]{\textcolor{orange}{ST:~{#1}}}
\newcommand{\TODO}[1]{\textcolor{olive}{TODO:~{#1}}}
\newcommand{\Q}[1]{\textcolor{blue}{Q:~{#1}}}
\setlength{\parskip}{0.2 cm}
\title{Notes articles}
\author{Maxime GONTHIER Samuel THIBAULT Loris MARCHAL}

\newcommand{\card}[1]{\ensuremath{\left|{#1}\right|}\xspace}
\newcommand{\live}{\ensuremath{L}\xspace}
\newcommand{\evict}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\dataset}{\ensuremath{\mathbb{D}}\xspace}
\newcommand{\taskset}{\ensuremath{\mathbb{T}}\xspace}
\newcommand{\packageset}{\ensuremath{\mathbb{P}}\xspace}
\newcommand{\inputs}{\ensuremath{\mathcal{D}}\xspace}
\newcommand{\optpb}{\textsc{Min\-Loads\-For\-Tasks\-Sharing\-Data}\xspace}
\newcommand{\nbloads}{\ensuremath{\mathit{\mathit{\#Loads}}}\xspace}
\newcommand{\MIN}{\ensuremath{\mathit{MIN}}\xspace}
\newcommand{\starpu}{\textsc{StarPU}\xspace}
\newcommand{\nbPU}{\ensuremath{\vert PU \vert}\xspace}

\usepackage{tikz}
\usetikzlibrary{fit, shapes.geometric, patterns}

\makeatletter\tikzset{hatch distance/.store in=\hatchdistance,hatch distance=5pt,hatch thickness/.store in=\hatchthickness,hatch thickness=5pt}\pgfdeclarepatternformonly[\hatchdistance,\hatchthickness]{north east hatch}{\pgfqpoint{-1pt}{-1pt}}{\pgfqpoint{\hatchdistance}{\hatchdistance}}{\pgfpoint{\hatchdistance-1pt}{\hatchdistance-1pt}}{\pgfsetcolor{\tikz@pattern@color}\pgfsetlinewidth{\hatchthickness}\pgfpathmoveto{\pgfqpoint{0pt}{0pt}}\pgfpathlineto{\pgfqpoint{\hatchdistance}{\hatchdistance}}\pgfusepath{stroke}}\makeatother\usetikzlibrary{calc,shadings,patterns,tikzmark}\newcommand\HatchedCell[5][0pt]{\begin{tikzpicture}[overlay,remember picture]\path ($(pic cs:#2)!0.5!(pic cs:#3)$)coordinate(aux1)(pic cs:#4)coordinate(aux2);\fill[#5]($(aux1)+(-0.23*0.075\textwidth,1.9ex)$)rectangle($(aux1 |- aux2)+(0.23*0.075\textwidth,-#1*\baselineskip-.8ex)$);\end{tikzpicture}}

\newcounter{nodemarkers}
\newcommand\circletext[1]{%
    \tikz[overlay,remember picture] 
        \node (marker-\arabic{nodemarkers}-a) at (0,1.5ex) {};%
    #1%
    \tikz[overlay,remember picture]
        \node (marker-\arabic{nodemarkers}-b) at (0,0){};%
    \tikz[overlay,remember picture,inner sep=2pt]
        \node[draw,ellipse,fit=(marker-\arabic{nodemarkers}-a.center) (marker-\arabic{nodemarkers}-b.center)] {};%
    \stepcounter{nodemarkers}%
}

% Pour les checkmark
\newcommand*\colourcheck[1]{%
  \expandafter\newcommand\csname #1check\endcsname{\textcolor{#1}{\ding{52}}}
}
\colourcheck{green}
\newcommand{\ok}[1]{\textcolor{ForestGreen}{OK \greencheck}}
\newcommand{\oktext}[1]{\textcolor{ForestGreen}{OK \greencheck}~\textcolor{ForestGreen}{#1}}

\begin{document}

%~ \tableofcontents
\newpage

\section{What's new since last meeting ?}

	\begin{enumerate}
		\item Using list in python is where it takes a lot of time
		\item New workload generation with day -1, day 0, 1 and 2
		\item It goes down before day 0 because it's job with huge walltime that failed and lastes a few seconds even tho they have the COMPLETED state. Should I remove them ?
		\item Plot distribution of queue/flow time with 2 schedulers on X and Y axis. 1 for all, different color for bigger jobs and smaller jobs	
		\item Heatmaps of stretch
		\item Code stretch and multiple scheduler same plot
	\end{enumerate}
	
\section{Questions for next meeting}

	\begin{enumerate}
		\item PDSEC et mailing list HPC ?
		\item Voir new algo big nodes
	\end{enumerate}

\section{Todo}
	\subsection{General}
		\begin{enumerate}
			\item Faire area comme photo loris
			\item Envoyer param hMETIS a Bora
			
			\item ajouter easy bf a fcfs avec un score si on le valide
			
			\item tester strat backfill on previous job avec data du orkload u on va utiliser en mode omnisicnet pour voir
			
			\item Ré écrire abstract et poster: Envoyer mail
		
			\item flow stretch courbe de points triée par walltime ou par delay au lieu de trier par job ids.
			
			\item Test fcfs score X plus grand
			
			\item Jobs commencé avant jour 0: je les ordonne comme l'ordo réel de traces. Ceux juste soumis sont toujours dans la queue. A coder et réécrire l'explication dans le document.
			\item tracer terminaison de ces jobs sur courbes usgae des nodes
			
			\item Contraintes tailles algo 3: calculer volume gros et petits jobs. Puis calculer la proportion de petits jobs que je peux mettre sur des plus grosses machines sans dépasser la proportion d'aires occupé par les gros jobs. Ecrire ca en théorie.
			
			\item Soumettre abstract avant le 15 et le ré écrire un peu
		
			\item Do test with 3 new plot methods
			\item tirer conclusions fcfs score
			\item tirer conclusions contraintes tailles en testant avec meme workload puis workload special avec des petits jobs aussi long que des gros
			\item Pareil contraintes tailles
			
			\item ré ecrire algos
			
			\item plot heat map of fcfs score with a parameter to 1 or 0 and the 2 others
			\item Virer 3eme multiplicateur et faire heat map pour voir des stretch
			\item prendre le stretch du flou (flow/flow cluster vide (avec transferts)) Moyenne mediane des ratio de tt les jobs ensuite.
			\item plot garder exposant sur l axe a gauche
			\item Enlever transferts sur courbes contraintes tailles et enlever les données d'entrées même si les algos les regardent
			\item mettre la rose sur la 12 pour contraintes. La 13 sert pas car trop desiquilibré
			\item plot stats ratio area et cluster
			\item Est-ce vraiment utile ?
			\item changer workload avec bcp de petit aussi long que les gros pour prouver que strat taille a un effet mais pas visible ssur des workloads classiques. et quelques gros pour voir.
			
		
			\item voir contraintes tailles
			\item re tester avec workload corrigées full et 5 jours
			\item retester avec autres algos
			\item profiler mon code pour voir ce qui coute du temps
			\item Se ré-inscrire à l'ENS avant le 15 Juin
			\item Envoyer abstract ACACES avant 15 juin
			\item Faire poster ACACES
			\item plots same stats with real data used from rackham history decision
			\item Rendre général le modèle des coeurs et des mémoires et des tailles des fichiers. Pour ce dernier chaque job a un fichier d'une certaine taille. Dans mo cas particulier la taille est un multiple de la taille de la mémoire des noeuds. Ensuite décrire la plateforme précise que j'utilise mais avant rendre le cas général. Décrire la plateforme au moment expé.
			\item Cours pour l'année prochaine
			\item Après avis favorable déposer dossier sur SIGED
			\item faire des boxplots
			\item faire option easy bf a la place de shceuler en particulier
			\item Voir thèses de Herman
			\item Talk to Hans Karlsson
			\item Lire articles Emanuel Rubensson \url{https://webmail.ens-lyon.fr/?_task=mail&_caps=pdf%3D1%2Cflash%3D0%2Ctif%3D0&_uid=4630&_mbox=INBOX&_action=show}
			\item Compare algo with different workloads. Use queue time of each job compared to a baseline. Compare queue time of each job between 2 heuristics by saying who won on each queue time.
			\item Code to compare ourselves, HEFT that would be FCFS that take into consideration transfer time for the earliest available cores
			\item Use same X scale for distributions of queue times
			\item Use same X scale workloads stats
			\item Use same X scale for some gantt charts when I want to compare them
			\item TODO du code: backfill, available node list qui contient les cores available aussi
			\item contrainte de la localié sur la taille de la données, contrainte sur les coeurs, contrainte sur les partage de données
			\item stratégie qui essaye d'utiliser moins les gros noeud pour les garder pour les gros jobs ?
			\item Lors d'une exec imprimer sur le terminal et dans le fichier de résultats les stats sur le workload et le cluster
			\item Comparer algo qui reschedule tout et algo qui schedule que quand un nouveau core est disponible et ne schedule que 1 seul job a la fois par cores.
			\item lire article bf : Utilization, Predictability, Workloads
			\item Faire plusieurs test et mettre une barre d'erreur
			\item Afficher temps de transferts sur les Gantt charts
			\item Rendre le code général en enlevant les 20 correspondant aux nombres de cores et en mettant une var globale initialisé lors de la lecture du cluster
		\end{enumerate}
	\subsection{Batsim}
		\begin{enumerate}
			\item Batsim a pas la granularité au sein d'un noeud
			\item Gérer n nodes
			\item Gérer n jobs
			\item Faire un delay aussi long que la somme du poids des données manquantes
			\item faire la maj des données du node partout, sois Dans le scheduler sois dans fit mais faut le faire!
			\item Gérér à la main les évictions
		\end{enumerate}

\end{document}
